<div align="center">
    <br />
    <br />
    <a href="https://github.com">
      <img src="https://private-user-images.githubusercontent.com/21144482/436623325-eb1e9cb3-72db-4d04-91e0-b66a7afb5f3c.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDY2NjcxMzAsIm5iZiI6MTc0NjY2NjgzMCwicGF0aCI6Ii8yMTE0NDQ4Mi80MzY2MjMzMjUtZWIxZTljYjMtNzJkYi00ZDA0LTkxZTAtYjY2YTdhZmI1ZjNjLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA1MDglMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwNTA4VDAxMTM1MFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTc2ZjA1MDBiNzY2OGQ0OGI1NjUxMjA2MWY1OTE5MjI2YmUxZmVlNDc4ZDRhYzQ0YjMzMTk3MDcwY2Q2NGJmNWUmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.JNrPIjWJ0z5V3QCmhIJW7mb38wUPZmx9uOfgWKtCerg" alt="SkeletonPub"  alt="SkeletonPub Logo" width="200">
    </a>
    <p>Clean Architecture, design for serverless</p>
    <br />
    <br />
</div>

<!-- Badges de tecnologias -->
<p align="center">
  <img src="https://img.shields.io/badge/Node.js-339933?style=for-the-badge&logo=nodedotjs&logoColor=white" alt="Node.js"/>
  <img src="https://img.shields.io/badge/TypeScript-3178C6?style=for-the-badge&logo=typescript&logoColor=white" alt="TypeScript"/>
  <img src="https://img.shields.io/badge/Jest-C21325?style=for-the-badge&logo=jest&logoColor=white" alt="Jest"/>
  <img src="https://img.shields.io/badge/Biome-292929?style=for-the-badge&logo=data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjRkZGIiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMTYgMTYiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnL3N2ZyI+PHBhdGggZD0iTTQgMUgxM0MxMy41NTIzIDEgMTQgMS40NDc3MSAxNCAyVjEzQzE0IDEzLjU1MjkgMTMuNTUyOSAxNCAxMyAxNEg0QzMuNDQ3NzEgMTQgMyAxMy41NTIzIDMgMTNWNEEzLjAwMzkgMy4wMDM5IDAgMDA0IDFaIi8+PC9zdmc+" alt="Biome"/>
  <img src="https://img.shields.io/badge/Clean%20Architecture-5C2D91?style=for-the-badge" alt="Clean Architecture"/>
  <img src="https://img.shields.io/badge/DDD-Domain%20Driven%20Design-blueviolet?style=for-the-badge" alt="DDD"/>
</p>

[![license](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](http://www.apache.org/licenses/LICENSE-2.0) [![codecov](https://codecov.io/gh/nasa/openmct/branch/master/graph/badge.svg?token=7DQIipp3ej)](https://codecov.io/gh/nasa/openmct) [![npm version](https://img.shields.io/npm/v/openmct.svg)](https://www.npmjs.com/package/openmct) ![CodeQL](https://github.com/nasa/openmct/workflows/CodeQL/badge.svg)
  <a href="https://github.com/facebook/jest"><img src="https://img.shields.io/badge/tested_with-jest-99424f.svg" alt="Tested with Jest"></a>
  <a href="#license"><img src="https://img.shields.io/github/license/sourcerer-io/hall-of-fame.svg?colorB=ff0000"></a>
<p>
SkeletonPub Microservices Framework foi desenvolvido para proporcionar uma estrutura base para a implementação de microservices. Utilizando conceitos do Domain-Driven Design, Clean Architecture, padrões SOLID e práticas como código limpo, o projeto visa facilitar e acelerar o desenvolvimento de aplicações escaláveis e de fácil manutenção.
</p>
> [!NOTE]
> Please visit our [Repository Site](https://github.com/iamelisandromello/skeleton) and [Getting Started Guide](https://github.com/iamelisandromello/skeleton/blob/main/README.md)

Depois de criar algo incrível com o SkeletonPub, mostre seu trabalho na nossa seção "Show and Tell" do GitHub Discussions. Adoramos ver implementações únicas e maravilhosas do microframework SkeletonPub!

![Skeleton Banner](https://private-user-images.githubusercontent.com/21144482/435825780-6a91069b-5683-43e0-982d-632235f14176.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDY2NjcyMzQsIm5iZiI6MTc0NjY2NjkzNCwicGF0aCI6Ii8yMTE0NDQ4Mi80MzU4MjU3ODAtNmE5MTA2OWItNTY4My00M2UwLTk4MmQtNjMyMjM1ZjE0MTc2LnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA1MDglMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwNTA4VDAxMTUzNFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTNmN2Q0MTA4YzZiNzRmMjM4NTZlYWY2NjkwOTk0NjA5MTk4ZGQzZjhhZjJlODI0OTkwNGE0YzBkMjY4YzY4MWYmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.ufwcPhxNQIc4PMn8QdlH1LcvqwYzs3yc0xZf7yTf9tQ)

<div align="center">
  <h1 align="center">
    SkeletonPub Project
  </h1>
</div>

## Introdução

Este é um projeto TypeScript/Node.js que serve como base para desenvolvimento de aplicações. O projeto inclui configurações para testes, formatação de código e ambiente de desenvolvimento.

## Requisitos

- Node.js
- npm ou yarn

## Instalação

1. Clone o repositório:
```bash
git clone [URL_DO_REPOSITÓRIO]
```

2. Instale as dependências:
```bash
npm install
```

3. Configure as variáveis de ambiente:
```bash
cp .env.example .env
# Edite o arquivo .env com suas configurações
```

## Desenvolvimento

### Executando o projeto
```bash
npm run dev
```

### Executando os testes
```bash
npm test
```

### Build do projeto
```bash
npm run build
```

## Ferramentas Utilizadas

- **TypeScript**: Linguagem de programação
- **Jest**: Framework de testes
- **Biome**: Ferramenta de formatação e linting
- **EditorConfig**: Padronização de configurações do editor

## Contribuição

1. Faça um fork do projeto
2. Crie uma branch para sua feature (`git checkout -b feature/nova-feature`)
3. Commit suas mudanças (`git commit -m 'Adiciona nova feature'`)
4. Push para a branch (`git push origin feature/nova-feature`)
5. Abra um Pull Request

## Licença

Este projeto está sob a licença MIT. Veja o arquivo [LICENSE](LICENSE) para mais detalhes.

## Contato

Para mais informações, entre em contato através dos canais de comunicação do projeto.


### Construindo e executando o SkeletonPub localmente

Construir e executar o SkeletonPub em seu ambiente de desenvolvimento local é muito fácil. Certifique-se de ter o Git e o Node.js instalados e siga as instruções abaixo. Precisa de mais informações? Confira a página "Como Começar" em nosso site. (Estas instruções pressupõem que você esteja instalando como um usuário não root; desenvolvedores relataram problemas ao executar estas etapas com privilégios de root.)

1. Clone the source code:

```sh
git clone https://github.com/iamelisandromello/skeleton-pub
```

2. (Optional) Install the correct node version using [nvm](https://github.com/nvm-sh/nvm):

```sh
nvm install
```

3. Install development dependencies (Note: Check the `package.json` engine for our tested and supported node versions):

```sh
npm install
```

4. Run a local development server:

```
npm start
```

> [!IMPORTANT]
> SkeletonPub is now running, and can be accessed by pointing a web browser at [http://localhost:8080/](http://localhost:8080/)

SkeletonPub is built using [`npm`](http://npmjs.com/) and [`webpack`](https://webpack.js.org/).

## 🏗️ Arquitetura

O projeto está organizado em camadas seguindo os princípios da Clean Architecture:

### 📁 Estrutura de Diretórios
```
src/
├── domain/             # Camada de Domínio
│   ├── entities/       # Entidades de negócio
│   ├── models/         # Modelos de dados
│   ├── enums/          # Enumeradores
│   ├── mocks/          # Dados mockados
│   └── usecases/       # Casos de uso
├── application/        # Camada de Aplicação
│   ├── contracts/      # Contratos e interfaces
│   ├── services/       # Serviços de aplicação
│   ├── duties/         # Responsabilidades
│   └── encapsulation/  # Encapsulamento
├── infra/              # Camada de Infraestrutura
│   ├── adapters/       # Adaptadores
│   ├── containers/     # Containers de DI
│   ├── database/       # Configurações de banco
│   ├── gateway/        # Gateways externos
│   └── validators/     # Validadores
├── presentation/       # Camada de Apresentação
│   ├── controllers/    # Controladores
│   ├── helpers/        # Auxiliares
│   └── interfaces/     # Interfaces de usuário
├── tests/              # Testes automatizados
├── docs/               # Documentação do projeto
├── dist/               # Arquivos compilados
├── .vscode/            # Configurações do VS Code
├── node_modules/       # Dependências do projeto
├── .env                # Variáveis de ambiente
├── .env.example        # Exemplo de variáveis de ambiente
├── .editorconfig       # Configurações do editor
├── .gitignore          # Arquivos ignorados pelo Git
├── biome.json          # Configuração do Biome (formatação e linting)
├── jest.config.js      # Configuração do Jest
├── package.json        # Dependências e scripts
├── tsconfig.json       # Configuração do TypeScript
└── tsconfig-build.json # Configuração de build do TypeScript
```
## 🧱 Design Arquitetural

Envolve decisões de alto nível sobre a estrutura e organização do sistema,
 definindo camadas, responsabilidades, fluxos de dependência e 
 separação de contextos. O foco está na arquitetura da solução, 
 garantindo escalabilidade, coesão e desacoplamento entre partes do sistema.
| Term          | Definition                                                                                                                                                                                                                                                                                                                                                   |
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| _**Domain Driven-Design**_ | Foco em modelar o domínio de negócio de forma rica e expressiva, com base na colaboração entre desenvolvedores e especialistas da área. Ele organiza o código em torno de contextos delimitados e linguagem ubíqua, facilitando a comunicação e a manutenção. DDD prioriza o entendimento profundo das regras e comportamentos do negócio antes da arquitetura técnica..                                                                                                                                                                                                                                                                  |
| _**Clean Architecture**_ | Código em camadas independentes, separando regras de negócio da infraestrutura e da interface. Ele promove alta manutenibilidade e testabilidade, permitindo trocar bancos de dados, frameworks ou UIs sem impactar o núcleo da aplicação. O foco está na inversão de dependência, com as regras de negócio no centro do sistema. |
| _**Composition Root**_ | Define um ponto único da aplicação onde todas as dependências são instanciadas e conectadas. Em projetos com Clean Architecture, esse papel é da camada Main, responsável apenas por orquestrar a aplicação. Usa-se Factories para criar e injetar dependências de forma explícita. Isso mantém o núcleo desacoplado, modular e testável.|
| _**Microservices Architecture**_ | Estrutura o sistema como um conjunto de serviços independentes, cada um responsável por um contexto específico de negócio.|
| _**Serverless Architecture**_ | Foca na execução de funções desacopladas, que escalam automaticamente e são executadas sob demanda em ambientes gerenciados.|
| _**Event-Driven Architecture**_ | Baseia-se na emissão, escuta e reação a eventos para comunicação entre componentes ou serviços.|

### 🌀 Clean Architecture
O projeto implementa a Clean Architecture através de uma clara separação de camadas:

```
src/
├── domain/          # Regras de negócio e entidades
├── application/     # Casos de uso e contratos
├── presentation/    # Interface com o usuário e comunicação
├── validation/      # Validações de entrada e saída
├── infra/          # Implementações técnicas
└── main/           # Composição e configuração
```

#### Domain Layer
- **Responsabilidade**: Contém as regras de negócio e entidades
- **Componentes**:
  - Entidades
  - Value Objects
  - Regras de negócio
  - Casos de Uso
- **Exemplo**:
```typescript
export interface UserEntity {
  email: string
  name: string
  username: string
}
```

#### Application Layer
- **Responsabilidade**: Orquestra o fluxo de dados e implementa casos de uso
- **Componentes**:
  - Interfaces de repositórios
  - Contratos de abstração de recursos externos
  - Serviços
  - Tasks
  - Transformers
- **Exemplo**:
```typescript
export interface UserRepository {
  findById(id: string): Promise<UserEntity>
  save(user: UserEntity): Promise<void>
}
```

#### Presentation Layer
- **Responsabilidade**: Gerencia a interface com o usuário e a comunicação
- **Componentes**:
  - Controllers
  - Helpers HTTP
  - Interfaces de usuário
  - Adaptadores de apresentação
- **Exemplo**:
```typescript
export abstract class Controller {
  abstract perform(request: HttpRequest): Promise<HttpResponse>
}
```

#### Validation Layer
- **Responsabilidade**: Valida dados de entrada e saída
- **Componentes**:
  - Validadores
  - Schemas
  - Regras de validação
  - Adaptadores de validação
- **Exemplo**:
```typescript
export interface Validator {
  validate(data: any): ValidationResult
}
```

#### Infrastructure Layer
- **Responsabilidade**: Implementa detalhes técnicos
- **Componentes**:
  - Repositórios
  - Gateways
  - Adaptadores externos
  - Configurações técnicas
- **Exemplo**:
```typescript
export class ExampleUserRepository implements UserRepository {
  constructor(
    private readonly connection: DatabaseConnection,
    private readonly transformer: UserTransformer
  ) {}
}
```

#### Main Layer (Composition Root)
- **Responsabilidade**: Composição e configuração
- **Componentes**:
  - Factories
  - Configurações
  - Adaptadores de infraestrutura
  - Ponto de entrada da aplicação
- **Exemplo**:
```typescript
export class ExampleUserRepositoryFactory {
  public make(): ExampleUserRepository {
    return new ExampleUserRepository(
      DatabaseConnections.catalyst,
      UserTransformerFactory.getInstance().make()
    )
  }
}
```
## 📦 Composition Root

O projeto implementa o Composition Root na camada Main, onde todas as dependências são instanciadas e compostas. A estrutura de factories atua como o ponto central de composição:

```
src/main/
├── factories/           # Composition Root
│   ├── adapters/       # Factories para adaptadores
│   ├── containers/     # Factories para containers
│   ├── gateway/        # Factories para gateways
│   ├── repositories/   # Factories para repositórios
│   ├── services/       # Factories para serviços
│   ├── transformers/   # Factories para transformers
│   └── connections/    # Factories para conexões
├── adapters/           # Implementações de adaptadores
└── config/            # Configurações da aplicação
```

### Exemplo de Composição de Dependências:

```typescript
// Composição de dependências usando factories
const userRepository = ExampleUserRepositoryFactory.getInstance().make()
const userTransformer = UserTransformerFactory.getInstance().make()
const errorContainer = ErrorContainerFactory.getInstance().make()
```


## 🗂️ Princípios SOLID

### 1. Single Responsibility Principle (SRP)
Cada classe tem uma única responsabilidade bem definida:

```typescript
// AdapterLambda: Responsável apenas por adaptar requisições Lambda
export class AdapterLambda {
  async handler(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {
    // Lógica de adaptação
  }
}

// ErrorContainer: Responsável apenas por gerenciar erros
export class ErrorContainer {
  constructor(private readonly errorsMap: Map<ErrorsEnum, Error>) {}
}
```
### 2. Open/Closed Principle (OCP)
O projeto utiliza interfaces e abstrações para permitir extensões sem modificar o código existente:

```typescript
// Interface genérica para containers
export interface ErrorContainerContract {
  getError(errorEnum: ErrorsEnum): Error
}

// Implementações específicas podem ser adicionadas sem modificar o código existente
export class ErrorContainer implements ErrorContainerContract {
  constructor(private readonly errorsMap: Map<ErrorsEnum, Error>) {}
}
```

### 3. Liskov Substitution Principle (LSP)
O projeto utiliza herança e implementação de interfaces de forma que subtipos possam ser substituídos por seus tipos base:

```typescript
// Todos os erros herdam de Error e podem ser usados de forma intercambiável
export class ServerError extends Error {}
export class TimeOutError extends Error {}
export class NotFoundError extends Error {}
```

### 4. Interface Segregation Principle (ISP)
Interfaces são específicas para cada necessidade:

```typescript
// Interface específica para transformação de usuários
export interface UserTransformer {
  transform(data: any): UserEntity
}

// Interface específica para repositórios
export interface UserRepository {
  findById(id: string): Promise<UserEntity>
  save(user: UserEntity): Promise<void>
}
```

### 5. Dependency Inversion Principle (DIP)
O projeto depende de abstrações, não de implementações concretas:

```typescript
// Dependência de abstração
export class ExampleUserRepository {
  constructor(
    private readonly connection: DatabaseConnection,
    private readonly transformer: UserTransformer
  ) {}
}
```

## 🏛️ Princípios de Design de Software

Foca nas decisões de baixo nível que impactam o código no dia a dia. 
São princípios que orientam clareza, simplicidade e reutilização durante a
escrita e manutenção do código, evitando redundância e complexidade desnecessária.
| Term          | Definition                                                                                                                                                                                                                                                                                                                                                   |
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| _**DRY**_ | **(Don't Repeat Yourself)**: Evitar duplicação de código. |
| _**YAGNI**_ | **(You Aren't Gonna Need It)**: Implementar apenas o necessário. |
| _**KISS**_ | **(Keep It Simple, Stupid)**: Manter a simplicidade. |
| _**LoD**_ | **(Law of Demeter)**: Cada unidade deve ter apenas conhecimento limitado sobre outras unidades: apenas unidades 'estreitamente' relacionadas à unidade atual. |
| _**SoC**_ | **(Separation of Concerns)**: A Separação de Preocupações implica dividir um sistema em partes distintas, cada uma responsável por uma funcionalidade específica. |
| _**GRASP**_ | **(General Responsibility Assignment Principles)**: Os princípios GRASP fornecem diretrizes sobre como atribuir responsabilidades dentro do design do software. Eles ajudam os desenvolvedores a criar sistemas mais coesos e com baixo acoplamento. |
| _**EwV**_ | **(Encapsulate What Varies)**: As partes do código que podem mudar devem ser isoladas, reduzindo o impacto de alterações, facilitando a manutenção e a evolução do software. |

## 🧰 Design Patterns

### 1. Singleton Pattern
O padrão Singleton é utilizado extensivamente nas factories para garantir uma única instância dos objetos. Exemplos:

```typescript
// ErrorContainerFactory
export class ErrorContainerFactory {
  private static instance: ErrorContainerFactory
  private instanceErrorContainer: ErrorContainer | undefined

  public static getInstance(): ErrorContainerFactory {
    if (!ErrorContainerFactory.instance) {
      ErrorContainerFactory.instance = new ErrorContainerFactory()
    }
    return ErrorContainerFactory.instance
  }
}

// UserTransformerFactory
export class UserTransformerFactory {
  private static instance: UserTransformerFactory
  private instanceUserTransformer: UserTransformer | undefined

  public static getInstance(): UserTransformerFactory {
    if (!UserTransformerFactory.instance) {
      UserTransformerFactory.instance = new UserTransformerFactory()
    }
    return UserTransformerFactory.instance
  }
}
```

### 2. Factory Pattern
O projeto utiliza factories para criar e gerenciar instâncias de objetos complexos. Exemplo do `ExampleUserRepositoryFactory`:

```typescript
export class ExampleUserRepositoryFactory {
  private static instance: ExampleUserRepositoryFactory
  private instanceExampleUserRepository: ExampleUserRepository | undefined

  public make(): ExampleUserRepository {
    if (!this.instanceExampleUserRepository) {
      this.instanceExampleUserRepository = new ExampleUserRepository(
        DatabaseConnections.catalyst,
        UserTransformerFactory.getInstance().make()
      )
    }
    return this.instanceExampleUserRepository
  }
}
```

### 3. Adapter Pattern
O padrão Adapter é utilizado para adaptar interfaces externas ao formato esperado pela aplicação. Exemplo do `AdapterLambda`:

```typescript
export class AdapterLambda {
  constructor(private readonly controller: Controller) {}

  async handler(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {
    const request: HttpRequest = { 
      query: event.queryStringParameters ?? {},
      body: JSON.parse(event.body ?? '{}'),
      path: null 
    }

    const httpResponse = await this.controller.perform(request)

    return {
      statusCode: httpResponse.statusCode,
      body: this.formatResponse(httpResponse),
      headers: cors()
    }
  }
}
```

### 4. Composite Pattern
O projeto utiliza o Composite Pattern para gerenciar erros através do `ErrorContainer`:

```typescript
export class ErrorContainerFactory {
  make(): ErrorContainerContract {
    const errorsMap = new Map<ErrorsEnum, Error>([
      [ErrorsEnum.SERVER_ERROR, new ServerError()],
      [ErrorsEnum.TIME_OUT_ERROR, new TimeOutError()],
      [ErrorsEnum.NOT_FOUND_ERROR, new NotFoundError('')],
      // ... outros erros
    ])

    return new ErrorContainer(errorsMap)
  }
}
```

## Convenções e Boas Práticas

### ✍️ Convenções de Nomenclatura e Semântica

Este projeto segue um conjunto bem definido de convenções de nomenclatura, adotadas para manter a consistência, legibilidade e padronização ao longo de todo o código. Essas práticas facilitam a manutenção, o trabalho em equipe e a escalabilidade da aplicação.

#### 📌 Padrões de Escrita

| Formato                | Uso                                                                  | Exemplo                          |
|------------------------|-----------------------------------------------------------------------|----------------------------------|
| `kebab-case`           | Arquivos                                                             | `controller-factory.ts`          |
| `camelCase`            | Variáveis compostas, funções e métodos                               | `getUser()`, `isUser`            |
| `lazycase` (minúsculas)| Variáveis simples                                                    | `total`, `soma`                  |
| `PascalCase`           | Classes, Entidades e Models                                          | `CreateUser`, `UserEntity`       |
| `SCREAMING_SNAKE_CASE` | Variáveis de ambiente e enums                                        | `DATABASE_URL`, `LOGIN_ERROR`    |

#### 🔤 Convenções Semânticas

- **Entidades e Models** devem ser nomeados no **singular**  
  Ex: `ProfileEntity`, `RoleModel`

- **Métodos** devem ser nomeados com **verbos**, expressando claramente sua ação  
  Ex: `getClient()`, `deleteClient()`, `setClient()`, `loadClient()`

- **Variáveis** devem indicar claramente o **tipo de dado armazenado**  
  Ex:  
  - `isValid` → booleano  
  - `user` → instância de um usuário  
  - `listAddress` → array de endereços

---
### 🧩 Boas Práticas

Essas convenções contribuem para um código mais limpo, intuitivo e alinhado com boas práticas do ecossistema TypeScript.

1. **Nomenclatura**
   - Factories: Sufixo `Factory`
   - Adaptadores: Sufixo `Adapter`
   - Transformers: Sufixo `Transformer`
   - Repositórios: Sufixo `Repository`

#### 🔁 Transformer  
**Arquivo:** `src/infra/database/transformers/user-transformer.ts`

```ts
export class UserTransformer implements UserAgreement {
  transform(params: UserAgreement.DataEntity): UserAgreement.Result {
    return {
      name: params.name,
      email: params.email,
      username: params.username
    }
  }
}
```
- O Transformer é responsável por converter os dados recebidos da fonte externa (como banco de dados ou API) para o formato de domínio esperado pela aplicação.
Neste exemplo, o UserTransformer transforma uma entidade genérica vinda da camada de persistência para um formato padronizado definido pelo contrato UserAgreement.

🗄️ Repositório
Arquivo: src/infra/database/repositories/example-user-repository.ts

```ts
export class ExampleUserRepository implements ExampleFindUserRepository {
  constructor(
    private readonly dbCatalystConnection: SQLConnection,
    private readonly userTransformer: UserAgreement
  ) {}
  // ...
}
```
- O Repositório atua como uma camada intermediária entre o domínio e a infraestrutura de persistência.
Aqui, ExampleUserRepository encapsula a lógica de acesso ao banco (via dbCatalystConnection) e utiliza o userTransformer para garantir que os dados estejam no formato adequado antes de serem retornados à aplicação.
Esse padrão promove o princípio da Inversão de Dependência, facilitando testes, manutenção e substituição de tecnologias sem afetar o núcleo do domínio.

2. **Estrutura de Arquivos**
   - Cada padrão em seu diretório específico
   - Separação clara de responsabilidades
   - Organização por features

- A estrutura do projeto demonstra uma clara separação de responsabilidades:
```
src/
├── domain/         # Entidades e regras de negócio
├── application/    # Casos de uso e serviços
├── infra/          # Implementações técnicas
├── main/           # Configuração e inicialização
├── validation/     # Validações
└── presentation/   # Interface com usuário
```

3. **Dependency Injection**
   - Injeção via construtores
   - Uso de factories para criação de instâncias
   - Inversão de controle

- Exemplo de injeção de dependência via construtores em src/application/services/example-service.
```ts
export class ExampleService implements ExampleUsecase {
  constructor(
    private readonly exampleLoadUser: ExampleLoadUserTreaty,
    private readonly treatment: TreatmentErrorContract
  ) {}
  // ...
}
```

4. **Tratamento de Erros**
   - Hierarquia de erros bem definida
   - Container de erros centralizado
   - Mapeamento de erros para códigos HTTP

- Hierarquia de erros: Encontrado em src/domain/enums/errors/errors-enum.ts:
```ts
export enum ErrorsEnum {
  SERVER_ERROR = 'serverError',
  NOT_FOUND_ERROR = 'notFoundError',
  UNAUTHORIZED_ERROR = 'unauthorizedError',
  // ...
}
```

- Container de erros: Encontrado em src/infra/containers/error-container.ts:
```ts
export class ErrorContainer implements ErrorContainerContract {
  constructor(
    private readonly customErrors: Map<ErrorContainerContract.ErrorsType, Error>
  ) {}
  // ...
}
```


## Boas Práticas Implementadas

1. **Organização de Código**
   - Estrutura de diretórios clara e consistente
   - Separação por responsabilidades
   - Nomenclatura descritiva

2. **Tipagem Forte**
   - Uso extensivo de TypeScript
   - Interfaces bem definidas
   - Tipos explícitos
   - Uso de Generics para tipagem específica

- Exemplo de interfaces bem definidas em src/application/contracts/database/find-repository.ts:

```ts
export interface FindRepository<T, R> {
  find: (filters?: T) => Promise<R>
}
```

3. **Modularização**
   - Cada módulo com responsabilidade única
   - Interfaces genéricas
   - Baixo acoplamento entre módulos
   - Alta coesão dentro dos módulos

- Exemplo de baixo acoplamento em src/application/contracts/database/example/user/example-find-user-repository.ts:
```ts
export interface ExampleFindUserRepository
  extends FindRepository<
    ExampleFindUserRepository.Filters,
    ExampleFindUserRepository.Result
  > {}
```

4. **Extensibilidade**
   - Classes Abstratas
   - Contratos bem definidos
   - Fácil adição de novas implementações

- Exemplo de classe abstrata em src/presentation/controllers/controller-abstract.ts:
```ts
export abstract class Controller {
  abstract perform(httpRequest: HttpRequest): Promise<HttpResponse>

  async handle(httpRequest: HttpRequest): Promise<HttpResponse> {
    try {
      return await this.perform(httpRequest)
    } catch (error) {
      return serverError(error)
    }
  }
}
```

## Convenções de Código

1. **Nomenclatura**
   - Interfaces começam com letra maiúscula
   - Tipos são descritivos e específicos
   - Namespaces para agrupar tipos relacionados

2. **Estrutura de Arquivos**
   - Um conceito por arquivo
   - Index files para exportação
   - Organização hierárquica de módulos

3. **Importações**
   - Paths aliases (@/)
   - Importações tipo-safe
   - Separação entre tipos e implementações


### Examples

The clearest examples for developing projects with the SkeletonPub archetype are in the
[tutorials](https://github.com/breathingcode-warkey/patterns-repository) provided in
our documentation.

> [!NOTE]
Queremos que o SkeletonPub seja o mais fácil de usar, instalar, executar e desenvolver
> possível, e seu feedback nos ajudará a chegar lá!
> O feedback pode ser fornecido por meio de [Problemas no GitHub](https://github.com/breathingcode-warkey/patterns-repository),
> [Iniciando uma Discussão no GitHub](https://github.com/breathingcode-warkey),
> ou enviando um e-mail para [arc-dl-openmct@mail.nasa.gov](mailto:imaelisandromello@gmail.com).

## Bibliotecas

### Dependências de Produção
Certain terms are used throughout SkeletonPub with consistent meanings
or conventions. Any deviations from the below are issues and should be
addressed (either by updating this glossary or changing code to reflect
correct usage.) Other developer documentation, particularly in-line
documentation, may presume an understanding of these terms.
| Term                  | Definition                                                                                                                                                                        |
|-----------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| _@aws-sdk/client-s3_  | Cliente oficial da AWS para interagir com o serviço S3 (armazenamento de arquivos e objetos) via código. Usado para upload, download, leitura e exclusão de objetos em buckets S3.|
| _@aws-sdk/client-sqs_ | Cliente oficial da AWS para interagir com o serviço SQS (filas de mensagens). Permite envio, leitura e remoção de mensagens em filas distribuídas.                                |
| _axios_               | Cliente HTTP baseado em Promises, usado para fazer chamadas REST (GET, POST etc.). Útil para consumir APIs externas de forma simples e robusta.                                   |
| _env-var_             | Validador e parser de variáveis de ambiente, garantindo tipos e presença. Facilita o uso seguro e tipado de process.env em TypeScript.                                            |
| _module-alias_        | Permite definir atalhos de importação com alias personalizados (ex: @/utils em vez de ../../utils). Melhora a legibilidade e organização dos imports em projetos grandes.         |
| _mongodb_             | Driver oficial do Node.js para conectar, consultar e interagir com bancos de dados MongoDB. Usado para realizar operações CRUD e manipular coleções/documentos.                   |
| _mysql2_              | Driver de banco de dados MySQL/MariaDB com suporte a Promises e prepared statements. Utilizado para conexões diretas, consultas e transações com MySQL.                           |
| _pg-promise_          | Biblioteca para PostgreSQL baseada em Promises, com foco em flexibilidade e desempenho. Ajuda na execução de queries SQL de forma segura, organizada e escalável.                 |
| _validator_           | Biblioteca para validação de strings (emails, URLs, números, etc.). Muito usada para validar inputs antes de processar ou persistir dados.                                        |

### Dependências de Desenvolvimneto
Certain terms are used throughout Open MCT with consistent meanings
or conventions. Any deviations from the below are issues and should be
addressed (either by updating this glossary or changing code to reflect
correct usage.) Other developer documentation, particularly in-line
documentation, may presume an understanding of these terms.
| Term                  | Definition                                                                                                                                                                    |
|-----------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| _@biomejs/biome_      | Ferramenta all-in-one para lint, formatter e análise estática de código TypeScript/JavaScript. Substitui ESLint, Prettier e outras ferramentas com configuração unificada.    |
| _@jest/globals_       | Fornece acesso direto aos métodos globais do Jest (describe, it, expect, etc.) via import. Evita poluir escopo global em configurações mais restritivas.                      |
| _@types/aws-lambda_   | Tipagens TypeScript para handlers de funções Lambda na AWS. Ajuda no autocomplete e validação ao escrever funções serverless.                                                 |
| _@types/jest_         | Tipagens TypeScript para usar o Jest com suporte completo a intellisense e validações de tipo. Necessário para usar Jest com TypeScript de forma segura.                      |
| _@types/module-alias_ | Tipagens para o pacote module-alias, permitindo suporte a imports com alias no TypeScript. Evita erros de tipo em tempo de compilação.                                        |
| _@types/node_         | Tipagens para APIs nativas do Node.js (como fs, path, process, etc.). Essencial para qualquer projeto TypeScript que roda no Node.                                            |
| _@types/validator_    | Tipagens para a biblioteca validator, permitindo uso com segurança de tipos. Evita erros ao validar inputs com funções como isEmail, isUUID, etc.                             |
| _glob_                | Utilitário para buscar arquivos via padrões glob (ex: src/**/*.ts). Usado em scripts para encontrar e processar múltiplos arquivos dinamicamente.                             |
| _jest_                | Framework de testes para JavaScript/TypeScript com foco em simplicidade e cobertura. Permite escrever, rodar e organizar testes automatizados com facilidade.                 |
| _ts-jest_             | Integra o TypeScript com o Jest, permitindo compilar e testar arquivos .ts diretamente. Necessário para rodar testes em TypeScript sem transpilar antes.                      |
| _ts-node_             | Executa arquivos TypeScript diretamente no Node.js, sem precisar compilar antes. Útil em dev para scripts rápidos ou comandos CLI escritos em TS.                             |
| _typescript_          | Compilador oficial da linguagem TypeScript. Transpila arquivos .ts em .js e verifica tipos estáticos no projeto.                                                              |
| _rimraf_              | Versão cross-platform do rm -rf, usada para limpar diretórios (como dist/). Comum em scripts de build para resetar a saída da compilação.                                     |

## ⚙️ Scripts NPM

Scripts auxiliares definidos no package.json para automatizar tarefas comuns
de desenvolvimento, build, testes e análise de qualidade de código.

#### How to Run Tests

- **"prepare:permission": "chmod ug+x .husky/*"**: Concede permissão de execução aos hooks do Husky (.husky/*), garantindo que funcionem corretamente no Git:

  ```sh
  npm prepare:permission
  ```

- **"dev": "node -r ts-node/register --env-file=.env src/main/index.ts"**: Inicia a aplicação em ambiente de desenvolvimento com suporte a TypeScript (ts-node) e variáveis de ambiente carregadas pelo .env:

  ```sh
  npm run dev
  ```

- **"clean": "rimraf dist"**: Remove a pasta dist, limpando os artefatos de build anteriores usando rimraf:

  ```sh
  npm run clean
  ```

- **"build": "npm run clean && tsc -p tsconfig-build.json"**: Executa a limpeza (clean) e compila o projeto com o TypeScript, utilizando tsconfig-build.json:

  ```sh
  npm run build
  ```

- **"start": "node -r dotenv/config dist/main/index"**: Executa a versão compilada da aplicação (em dist/), utilizando as variáveis do .env:

  ```sh
  npm run start
  ```

- **"check": "npm-check -s -u"**: Utiliza o npm-check para verificar e atualizar interativamente as dependências do projeto:

  ```sh
  npm run check
  ```

- **"lint": "npx @biomejs/biome check src"**: Verifica a qualidade e padronização do código com o Biome, sem fazer alterações:

  ```sh
  npm run lint
  ```

- **"lint:format": "npx @biomejs/biome check --write src"**: Verifica e formata automaticamente os arquivos de código-fonte com o Biome:

  ```sh
  npm run lint:format
  ```

- **"test": "jest --passWithNoTests"**: Executa a suíte de testes com o Jest, mesmo que não existam testes definidos ainda:

  ```sh
  npm run test
  ```
  
All tests are located within the `e2e/tests/` directory and are identified by the `*.e2e.spec.js` filename pattern. For more information about the e2e test suite, refer to the [README](./e2e/README.md).



## Repositórios Relacionados

> [!NOTE] Embora o SkeletonPub funcione como um projeto independente, ele é essencialmente um microframework extensível projetado para ser usado como dependência, com base no conceito de arquitetura como dependência, com plugins e pacotes de propriedade do usuário. Um ótimo exemplo de hospedagem do SkeletonPub em projetos serverless de produção é o WarKey.
